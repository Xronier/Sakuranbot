import os
from discord.ext.commands import bot
from discord.ext import commands
import sqlite3
import discord
from .MultiQuestion import MultiQuestion

class CompoundQuestion(MultiQuestion):
    def __init__(self, correct, incorrect, options, correct_misc, question_num, c_range):
        super().__init__(correct, incorrect, options, question_num)
        self.correct_misc = correct_misc
        self.c_range = c_range

        # Returns the Onyomi of the correct answer (i.e kan)
    def get_correct(self):
        return self.correct

        # Returns all info (in the DB) about the correct answer.
    def get_correct_misc(self):
        return self.correct_misc

        # Returns a list of the Onyomi of the incorrect answers (i.e [chi, sou, kyou]).
    def get_incorrect(self):
        return self.incorrect

        # Returns a list of Onyomi of the incorrect answers + correct answer.
    def get_options(self):
        return self.options

    def get_answer_positions(self):
        return self.answer_positions

    def get_c_range(self):
        return self.c_range

    def get_question_num(self):
        return self.question_num

    # Formatted string of the correct answers misc info.
    def get_correct_misc_str(self):
        return "Meaning: {} \n" \
               "Frequency: {} \n" \
               "Rank: {}".format(self.get_correct_misc()[3], self.get_correct_misc()[4], self.get_correct_misc()[0])

    async def format_question(self, level):
        embed = discord.Embed(title="Question: {}".format(self.get_question_num()))
        embed = embed.add_field(name="What is the reading of {}".format(self.get_correct_misc()[1]),
                                value=":one: {}\n"
                                      ":two: {}\n"
                                      ":three: {}\n" 
                                      ":four: {}".format(self.get_options()[self.get_answer_positions()[0]],
                                                         self.get_options()[self.get_answer_positions()[1]],
                                                         self.get_options()[self.get_answer_positions()[2]],
                                                         self.get_options()[self.get_answer_positions()[3]]), inline=False)
        embed = embed.set_footer(text="Compound Quiz Range: {} to {}".format(self.get_c_range()[0], self.get_c_range()[1]))
        return embed

    async def verify_answer(self, reaction):
        if reaction.emoji == "1️⃣":
            return self.get_options()[self.get_answer_positions()[0]] == self.get_correct()
        elif reaction.emoji == "2️⃣":
            return self.get_options()[self.get_answer_positions()[1]] == self.get_correct()
        elif reaction.emoji == "3️⃣":
            return self.get_options()[self.get_answer_positions()[2]] == self.get_correct()
        elif reaction.emoji == "4️⃣":
            return self.get_options()[self.get_answer_positions()[3]] == self.get_correct()

    async def add_reaction(self, emojis, embed):
        for e in emojis:
            await embed.add_reaction(emoji=e)


    async def show_result(self, ctx, result):
        compound = self.get_correct_misc()[1]
        if result:
            embed = discord.Embed(title="Correct! Jisho Link to {}".format(compound),
                                  url="https://jisho.org/word/{}".format(compound),
                                  color=discord.Colour.green())
            embed = embed.add_field(name="Correct Answer", value="{}".format(self.get_correct()), inline=False)
            embed = embed.add_field(name="Information", value="{}".format(self.get_correct_misc_str()))
            await ctx.send(embed=embed)
        else:
            embed = discord.Embed(title="Incorrect... Jisho Link to {}".format(compound),
                                  url="https://jisho.org/word/{}".format(compound),
                                  color=discord.Colour.red())
            embed = embed.add_field(name="Correct Answer", value="{}".format(self.get_correct()), inline=False)
            embed = embed.add_field(name="Information", value="{}".format(self.get_correct_misc_str()))
            await ctx.send(embed=embed)

def generate_question(c_range, question_num):
    c_range = c_range.split(",")
    db = sqlite3.connect('kanji.sqlite')
    cursor = db.cursor()

    answer = cursor.execute("SELECT * FROM compounds WHERE Frequency > {} AND Frequency < {} ORDER BY RANDOM() LIMIT 1".format(c_range[0], c_range[1])).fetchone()
    incorrect = cursor.execute("SELECT Pronunciation FROM compounds ORDER BY RANDOM() LIMIT 3").fetchall()

    options = []
    for i in range(len(incorrect)):
        options.append(incorrect[i][0])
    options.append(answer[2])
    cq = CompoundQuestion(correct=answer[2], incorrect=incorrect, options=options, correct_misc=answer, question_num=question_num, c_range=c_range)

    # Close DB
    cursor.close()
    db.close()
    return cq
